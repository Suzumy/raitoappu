# only_read
## Beginners_CTF_2021
## reversing
***

とりあえず実行ファイルをobjdumpにかける
> objdump -d -M intel ./chall

mainがあったため、まずmainに目を向けて解析してみる。
mainの中からほかに呼ばれている関数がないか調べてみる。
関数が呼ばれるときは基本callが使われるため、callの部分を見てみると、以下の関数が呼ばれていることが分かった。
* read
* puts
* __stack_chk_fail

標準関数以外の関数が呼ばれていそうな気配がないため、処理はmainで完結していると仮定して調べていく。

mainを上から見ていくのでもいいが、時間がかかるしそもそもバイナリが読めないため、
必要最低限だけ読んでいく。今回はif文にあたるcmp命令の前後を見ていく。

初めのcmpは
```
<+91>:    cmp    al,0x63
<+93>:    jne    0x80012c6 <main+317>
```

となっている。

まずjneということはZF=0の時にジャンプすることになる。次にcmp al,0x63を比較するが、この時alの中身がわからないため、まずalの中身がどうなっているかを考える。alはraxの下位8bitになるため、eaxの値をgdbで調べてみる。

コマンドはこんな流れ
```
gdb //gdbの起動
b *main+91 //main+91にブレイクポイントを設定
r //プログラムをブレイクポイントまで走らせる
```
ここで文字列の入力が求められるため、今回は適当にhogeとか入力する。

次に
> i r

とする。
```
gdb-peda$ i r
rax            0x68     0x68
rbx            0x0      0x0
.
.
.
```


0x68はasciiでhを示すため、この時eaxには入力した情報の先頭文字が入っていることが分かる。つまりここのif文では最初の文字が0x63(c)であるかを比較していることがわかる。

それを踏まえて次のcmpを見ると
```
cmp    al,0x74
```

同じく0x74(t)と比較していることがわかる。
ちなみに前提としてフラグのフォーマットがctf4b{}であることを前提に考えると、ここまでのctとフォーマットの先頭2文字が一致していることが分かる。つまり、この処理がフラグ文字列との比較をしていることが想像できる。

とすると、同じ処理が他にもあると考えられるため、cmp命令を見ていく。
```
cmp    al,0x63
cmp    al,0x74
cmp    al,0x66
cmp    al,0x34
cmp    al,0x62
cmp    al,0x7b
cmp    al,0x63
cmp    al,0x30
cmp    al,0x6e
cmp    al,0x35
cmp    al,0x74
cmp    al,0x34
cmp    al,0x6e
cmp    al,0x74
cmp    al,0x5f
cmp    al,0x66
cmp    al,0x30
cmp    al,0x6c
cmp    al,0x64
cmp    al,0x31
cmp    al,0x6e
cmp    al,0x67
cmp    al,0x7d
```

上からc,t,f,4,b,{...となっている。これはフラグで間違いなさそうなので、数字だけピックアップして文字に戻してみる

```
list=[0x63, 0x74, 0x66, 0x34, 0x62, 0x7b, 0x63, 0x30, 0x6e, 0x35, 0x74, 0x34, 0x6e, 0x74, 0x5f, 0x66, 0x30, 0x6c, 0x64, 0x31, 0x6e, 0x67, 0x7d]
for i in list:
    print(chr(i), end="")
```

出力されたフラグをsubmitする。