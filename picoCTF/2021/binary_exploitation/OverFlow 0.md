# OverFlow 0
## picoCTF2019
## Binary Exploition
***
プログラムと実行ファイルが配布される。  
以下配布プログラム
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  fprintf(stderr, "%s\n", flag);
  fflush(stderr);
  exit(1);
}

void vuln(char *input){
  char buf[128];
  strcpy(buf, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  
  if (argc > 1) {
    vuln(argv[1]);
    printf("You entered: %s", argv[1]);
  }
  else
    printf("Please enter an argument next time\n");
  return 0;
}
```
プログラムを読むと
> FILE *f = fopen("flag.txt","r");

の辺りでフラグが書かれたファイルの読み込みを行っており、そのあと
> fgets(flag,FLAGSIZE_MAX,f);

で実際にフラグの中身をflagという変数に読み込んでいることがわかる。  
つまりこの問題ではflagという変数の中身を見ることが出来ればいいことがわかる。ただmain関数の中にはこれを標準出力に書き出す処理は書かれていない。ではどこにあるかというと、上のsigsegv_handler関数の中にある。  
次にこのsigsegv_handler関数をどうやって呼び出すかという問題だが、プログラムを見ると、
> signal(SIGSEGV, sigsegv_handler);

という処理がある。このsignal関数は、システムコールを監視しておく関数で、第一引数にあるシステムコールが発生した場合に第二引数の関数を呼び出す処理を行う。  
今回の場合、SIGSEGVは不正なメモリ参照が起こった場合のため、その時sigsegv_handlerが呼び出されることになる。ではどうやって不正なメモリ参照を起こすか。ここで問題文のOverFlowが出てくる。バッファオーバーフローを使ってフラグを表示させる。  
このプログラムでは実行時の引数を入力としているため、プログラムを実行する際に
> ./vuln aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

って感じで入力する。するとバッファオーバーフローが起きる -> 不正なメモリ参照が起こる -> SIGSEGVが起きてsigsegv_handlerが呼ばれる -> フラグ表示  
みたいな感じでフラグが出る。