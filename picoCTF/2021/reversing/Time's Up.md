# Time's Up
## reversing
## picoCTF2021
***

実行ファイルが与えらえるため、まずこれを実行してみる。  
```
suzumy@LAPTOP-EOURP8FK:~$ ./times-up
Challenge: (((((-1753540812) - (-1633965460)) + ((1033348087) + (1847818964))) - (((1688904640) + (2004319610)) + ((1315337418) - (794501440)))) + ((((453550962) + (242239344)) + ((71863431) + (1258751851))) + (((-1843681984) - (-737222924)) - ((312639568) + (-678502002)))))
Setting alarm...
Solution? Alarm clock
```
計算式っぽいのがめっちゃ出てきてる。たぶんこれを計算して答えを入力する感じだと思うけど、入力する前にプログラムが終了しているため確かめられない。  
そのため、一旦パイプで適当な数字を入力して実行してみる。  
```
suzumy@LAPTOP-EOURP8FK:~$ echo 178 | ./times-up
Challenge: (((((217932503) + (-1441456552)) - ((1954709160) + (-596835081))) + (((719939356) + (-2134892632)) + ((73021866) - (-1888323106)))) + ((((-1609343677) + (-1111973376)) + ((300177500) + (-2079888800))) + (((-841808382) + (1074142213)) + ((-57959633) - (-16803697)))))
Setting alarm...
Solution? Nope!
```
178という数字を入れた結果先ほどとは違いNope!が返ってきた。どうやら計算させるのは合ってるっぽい。時間がないところはプログラムにさせればいいため、bcコマンドを使う。  

ネットのwriteupの内容をそのまま使ったスクリプトがこちら  
```
coproc ./times-up								//times-upのプロセスを起動
read LINE <&${COPROC[0]}						//起動したプロセス0番目の出力をLINEに格納
echo $(echo ${LINE:11} | bc) >&${COPROC[1]}		//LINEの中身の11文字目からの出力をbcに渡して計算させる。結果をtimes-upのプロセスに入力する
cat <&${COPROC[0]}								//times-upからの出力をcatで確認する。
//[0]が出力、[1]が入力だと思う
```
これをshell上に張り付けるとそれぞれコマンドが実行されてflagが表示される。