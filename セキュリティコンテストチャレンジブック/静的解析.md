
## レジスタとスタック

レジスタ - プロセッサ内に存在する記憶装置のこと。メモリや補助記憶装置に比べ高速に動作する。このためプロセッサが
    命令を実行する際は、直接メモリを操作するのではなく、メモリからレジスタに読み出した値を操作することが多い。
    プロセッサは32bitや64bitのものが多く、たいていはメモリより容量が小さい。
    ここから一般的に、32bitCPU、64bitCPUと呼ぶ。
    プロセッサにはたいてい複数のレジスタがあり、用途により使い分ける。

x86アーキテクチャのレジスタには以下の種類がある。
    汎用レジスタ - 基本的にどんな使い方をしても問題ない。しかし、基本的にはそれぞれのレジスタに通例の使い道があり、
        その使い道による別名が用意されている。
    ・EAX(アキュムレータ)演算結果を格納する
    ・ECX(カウンタレジスタ)ループ回数などのカウントを格納する
    ・EDX(データレジスタ)演算に用いるデータを格納する
    ・EBX(ベースレジスタ)アドレスのベース値を格納する
    ・ESI(ソースインデックスレジスタ)一部のデータ転送命令について、データの転送元を格納する
    ・EDI(デスティネーションインデックスレジスタ)一部のデータ転送命令について、データの転送元を格納する

    特殊レジスタ - それぞれに専用の使い道がある。
    ・EBP(ベースポインタレジスタ)現在のスタックフレームにおける底のアドレスを保持する
    ・ESP(スタックポインタレジスタ)現在のスタックトップのアドレスを保持する
    ・EIP(インストラクションポインタレジスタ)次に実行するアセンブリ命令のアドレスを保持する
    上からベースポインタ、スタックポインタ、命令ポインタと呼ぶこともある。

    フラグレジスタ - 前の命令による操作の結果として生じた状態やプロセッサの状態を格納する。
    ・EFLAGS - 1個32bitのレジスタで実装され、その中に17個のフラグが格納される
        ・CF(キャリーフラグ)演算命令でキャリー(桁上がり)かボロ―(桁借り)が発生した際にセットされる
        ・ZF(ゼロフラグ)操作の結果がゼロだった時にセットされる
        ・SF(符号フラグ)操作の結果が負になった時にセットされる
        ・DF(方向フラグ)ストリームの方向を制御する
        ・OF(オーバーフローフラグ)符号付き算術演算の結果がレジスタの格納可能範囲を超えた場合にセットされる。
    
    セグメントレジスタ - セグメントのアドレスを参照するのに用いる。
    ・CS(コードセグメントレジスタ)コードセグメントのアドレスを格納
    ・DS(データセグメントレジスタ)データセグメント
    ・SS(スタックセグメントレジスタ)スタックセグメント
    ・ES(エクストラセグメントレジスタ)エクストラセグメント
    ・FS(Fセグメントレジスタ)同上
    ・GS(Gセグメントレジスタ)同上

    ESI,EDIはまとめてインデックスレジスタと呼ばれることもある。どのレジスタも32bitのレジスタ長を持つ。
    汎用レジスタの内、EAX, ECX, EDX, EBXの下位16bitはAX, CX, DX, BXレジスタと呼ばれ、この下位bitの中の
    上位8bitがAH(High), CH, DH, BH、下位8bitがAL(Low), CL, DL, BLレジスタと呼ばれる。

    ESI、EDIレジスタの下位16bitはそれぞれSI, DIレジスタと呼ばれる。

x86-64アーキテクチャのレジスタ - x86アーキテクチャのレジスタを拡張したもの。レジスタ幅が64bitとなっている。
    x86アーキテクチャのレジスタを拡張してRAX, RCX, RDX, RBX, RDI, RSI, RBP, RIPとなる。
    このアーキテクチャの下位32bitがEAXとなっており、これより下位もx86と同様になっている。

x86アセンブリ命令と記法
    アセンブリ言語には、intel記法とAT&T記法の二つの記法が存在する。二つの一番大きな違いはオペランドの順番が違うことにある。例えばmov命令で5を格納する際、
    intel - mov eax, 5
    AT&T  - mov $%, %eax
    となっている。

    アセンブリでは、オペランドにメモリアドレスを指定して、そのアドレスに格納されている内容を参照することができる。
    EBXレジスタに格納されたアドレスを参照し、そのアドレスに格納されている値をEAXに格納するする処理、を行うとき、
    intel記法では[]で囲まれた中身を参照するアドレスとして解釈する
    mov eax, [ebx] ebxが[]で囲まれているため、ebxに格納されたアドレスの中身をeaxに入れる。

    あるメモリアドレスから特定の変位、つまり、あるアドレスから+nしたアドレスというような処理をかける。
    mov eax, [ebx+4]

    変位に加え、オフセットレジスタやスケーラを指定することができる。この場合、ベースレジスタ+変位+オフセットレジスタ*スケーラの位置アドレスにアクセスすることになる。ループの際にEDIの値を添え字に数字を変化させながら配列にアクセスしたい時などに用いる。
    mov eax, [ebx+8+edi*4]

    レジスタにサイズが存在するように、アセンブリ言語のオペランドにはサイズを明示する必要がある。
    intel記法の場合、オペランドがレジスタの場合は自動でサイズを認識してくれるが、メモリサイズの場合は明示的にサイズを指定する必要がある。サイズには以下がある。
    ・BYTE:バイト(8bit) - 1byteは8bitのため
    ・WORD:ワード(16bit)
    ・DWORD:ダブルワード(32bit) - 16*2 = 32
    ・QWORD:クワッドワード(64bit) - 16*4 = 64

    例えば以下のように記述する
    mov BYTE PTR [eax], 5

アセンブリの基本命令
    mov - srcをdestにコピーする
    mov dest, src

    lea - srcのアドレスを計算し、そのアドレスをdestにロードする。
    lea dest, src

    xchg - arg1とarg2の値を交換する
    xchg dest1, dest2

    lodsb - [DS:ESI]レジスタの内容を1バイト分ALレジスタに読み込む
    lodsb

    stosb - lodsbの反対。ALレジスタの内容を[ES:EDI]レジスタに書き込む
    stosb

    push - argの値をスタックにプッシュする。具体的には、ESPレジスタの値をレジスタの幅分(32bitや64bit)減算し、
        argをESPレジスタの指すスタックトップに格納する。
    push src

    pop - スタックからargに値を取り出す。具体的には、ESPレジスタの指すスタックトップの値をargに格納し、
        ESPレジスタの値をレジスタ幅分加算する。
    pop dest

    add - destにsrc加算した値をdestに格納する。
    add dest, src

    sub - addの引き算
    sub dest, src

    mul - srcオペランドにEAXレジスタの値を乗算、結果の上位4バイトをEDXレジスタに、下位4バイトをEAXレジスタに
        格納する。
    mul

    div - EDX:EAXの8バイトをオペランドの値で除算し、商をEAXに、剰余をEDXに格納する。
    div src

    inc, dec - インクリメント、デクリメントを行う。

    cmp - subと同じく減算を行うが、結果はレジスタには格納せず破棄する。この際フラグレジスタを変化させる。
        例えば二つの値が等しい場合、減算の結果は0となるため、ZF=1となる。
    cmp src1, src2

    shl, shr - destをcountで指定したビット分それぞれLeft, Rightにシフトする。結果をdestに格納する。
    shl dest, count
    shr dest, count

    ror, rol - destをcount分ローテーションさせる。
    ror dest, count
    rol dest, count

    xor - destとsrcのEXORをdestに格納する。この命令はxor eax, eaxのように利用されることが多い。
        xor eax, eaxだと同じ値のため、eaxの値が0となる。このためレジスタの初期化によく使われる。
    xor dest, src

    test - src1とsrc2の論理積(or)をとる。cmpと同じく結果は破棄され、フラグレジスタを変化させる。
    test src1, src2

    jmp - 実行をargへと分岐させる。
    jmp arg

    call - jmpと同じく実行をargへ分岐させる。違う点は分岐した先で実行終了後に戻ってこられるように処理を施す点。
    call arg

    ret - callと対で使い、callされた関数の終わりで呼び出し元の関数に戻る為の命令
    ret

    leave - データ転送命令。retとセットで使われることが多い。
        関数の最後で、ret命令の前に呼び出され、スタックポインタをベースポインタと同じ位置に戻し、スタック上に保存していた呼び出しもとのスタックフレームでのベースポインタを復元する。
    leave


逆アセンブルの解析
    プログラムは主に条件分岐、API呼び出し、演算命令の組み合わせで動いていることがわかる。

エントリーポイント付近
    C言語ではプログラムはmain関数から始まるものだが、これをコンパイルしたバイナリは、mainから始まるわけではない。
    レジスタやスタックの初期化やmainに渡すコマンドライン引数の処理などはmainの前ににする必要がある。linuxなどでは
    エントリポイントからこの処理を行ったうえで、__libc_start_mainという関数を呼び出し、mainへと移る。この処理の例が
    以下
```
public start
start proc near
      xor   ebp, ebp
      pop   esi
      mov   ecx, esp
      push  eax
      push  esp
      push  edx
      push  offset fini
      push  offset init
      push  ecx
      push  esi
      push  offset main
      call  __libc_start_main
      hlt
start endp
```

条件分岐
プログラムにはifやforがあるため、条件分岐の流れをつかむことが大事。アセンブリの条件分岐には大まかに以下の種類がある。
・JE(jump if equal), JZ(jump if zero):ZF=1の時分岐
・JNE(jump if not equal),JNZ(jump if not zero):ZF=0の時分岐
・JG(jump if greater):ZF=0かつSF=OFの時分岐
・JL(jump if else):SF <> OFの時分岐

cmpやsub命令では、演算結果、第一オペランドが大きければSF=0、第二オペランドが大きければSF=1、等しければZF=0
というようにフラグレジスタを変化させる。

test命令は、or演算を行うため、第一オペランドと第二オペランドがどちらも0の時のみ演算結果が0となり、ZF=1となる。
これを利用し、test eax, eaxのように第一第二オペランドに同じものをとり、オペランドのレジスタが0かどうか調べる。

条件分岐の典型
・EAXレジスタが5の場合、Nextにジャンプする。
cmp eax, 5 //eaxが5の時、eax(5) - 5 = 0のため、ZF=1となる
je Next    //ZFが1のため、条件が真となり、ジャンプする。

・EAXが0の場合、Nextにジャンプする。
test eax, eax //eaxが0の時、両方0のためZFが1となる
jz Next       //ZF=1のため、ジャンプする

・ループ処理
    xor ecx, ecx
loc_1:
    call func
    inc ecx     //ecxをインクリメント
    cmp ecx, 5  //ecxが5でない場合、ecx(1) - 5 = -4
    jne loc_1   //4まではZF=0のためジャンプ、5になるとZF = 1になるためジャンプせずループから抜ける

関数と呼び出し規約
    呼び出し規約 - アセンブリのサブルーチンにおける、引数の渡し方や返り値の返し方を決めたもの。一般的に決められたレジスタやスタックが使われる。

    sample.c
    ```
    int Func(int arg1, int arg2, int arg3, int arg4, int arg5);
    int arg1, arg2, arg3, arg4, arg5, ret;

    retval = Func(arg1, arg2, arg3, arg4, arg5);
    ```

stdcall - windows APIでも使われる一般的な呼び出し規約。引数が、順番が後のものからスタック上にpushされる。
    サブルーチン実行後は返り値はEAXレジスタに格納される。

```
push arg5
push arg4
push arg3
push arg2
push arg1
call Func
mov retval, eax
```

cdecl - stdcallとおおきくは変わらないが、ESPレジスタに値を戻す処理が呼び出し先から戻って来たことろで実施されている。

```
push arg5
push arg4
push arg3
push arg2
push arg1
call Func
add esp, 14h
mov retval, eax
```

関数呼び出しとスタック
関数の呼び出しの際、ほとんどの場合でスタックが使われる。以下のプログラムを元にどのようにスタックが動くのかを調べる

> Func1
```
push arg2
push arg1
call Func2
mov retval, eax
```

> Func2
```
push ebp
mov ebp, esp
sub esp, 100h
mov eax, [ebp+8]
mov ebx, [ebp+Ch]
...
mov esp, ebp
pop ebp
ret
```

ここからは図で書いていく。スタック図を書く時は、高位のアドレスが上に、低位のアドレスが下に来る用意書き、下に伸びていくようにスタックを書く。スタックの1ブロックは4バイトとする。

| スタック図 |
------
| ... | <---ebp
| ... |
| ... |
| ... |
| arg2 |
| arg1 |
| retaddr | <____esp

Func1を実行したとき、まずarg2,arg1とpushされ、call命令が実行されたタイミングでEIPレジスタがFunc2の命令アドレスとなり、実行がFunc2へ飛ぶ。この時Func2実行後Func1に戻れるようにcall命令の次の命令アドレス(mov retval, eax)をリターンアドレスとしてスタックに積む。

次にFunc2の実行へ移る。Func2の初めにpushによりEBPレジスタの値がスタックに積まれる。これによりEBPレジスタの値を保存し、Func2が終了してFunc1に戻るときにスタックフレームを戻せるようにしておく。

| スタック図 |
------
| ... | <---Func1のebp
| ... |
| ... |
| ... |
| arg2 |
| arg1 |
| retaddr | <____Func1のesp
| Func1のebp |
|  | <---ebp,esp

次にsub esp, 100hでESPレジスタの値を低位に移動させる。この時EBPとESPの間に出来た領域が、ローカル変数の格納
に利用される。

| スタック図 |
------
| ... | <---Func1のebp
| ... |
| ... |
| ... |
| arg2 |
| arg1 |
| retaddr | <____Func1のesp
| Func1のebp |
| ローカル変数を保存する | <---ebp
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する | <_____esp

続くmovでFunc2がどのように引数にアクセスするか調べる。
スタックを調べると、ebpからの4バイトでFunc1のebpが保存されており、そのあと8バイトでarg1が
12バイトでarg2が存在していることが分かる。
つまりここのebp+8はarg1の値を、ebp+Chはarg2の値を示していることがわかる。
このように、ebpレジスタから見た引数の値は常に一定となるため、引数にはebpレジスタの位置からの変位を利用して
アクセスする。

| スタック図 |
------
| ... | <---Func1のebp
| ... |
| ... |
| ... |
| arg2 |  < ---ebp+12
| arg1 |　< ---ebp+8
| retaddr | <____Func1のesp
| Func1のebp |
| ローカル変数を保存する | <---ebp
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する | <_____esp

関数の最後では、ESPレジスタにEBPレジスタの値をコピーしている。これにより、スタックポインタの位置をFunc2が呼ばれた直後の状態に戻す。これにより、スタックに保存していたローカル変数などの値はメモリ上には残るものの、もう使わないことになる。

| スタック図 |
------
| ... | <---Func1のebp
| ... |
| ... |
| ... |
| arg2 |  < ---ebp+12
| arg1 |　< ---ebp+8
| retaddr | <____Func1のesp
| Func1のebp |
| ローカル変数を保存する | <---ebp, esp
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する |

そして保存していたEBPレジスタの値をpopすることで復元する。これによりebpの値もFunc1の場所に戻る。
この処理はleaveで可能なため、代わりにleaveと書くこともある。

| スタック図 |
------
| ... | <---ebp
| ... |
| ... |
| ... |
| arg2 |
| arg1 |
| retaddr | <____esp
| Func1のebp |
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する |

最後にretを実行する。これにより、保存していたリターンアドレスをEIPにpopするため、次に実行される命令がmov retval, eaxとなる。

| スタック図 |
------
| ... | <---ebp
| ... |
| ... |
| ... |
| arg2 |
| arg1 |　<____esp　
| retaddr | 
| Func1のebp |
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する |
| ローカル変数を保存する |

ここまでが関数呼び出しから呼び出し元に戻るまでの処理となる。

静的、動的リンク
動的リンク - 外部のライブラリファイル(.soやdll)をリンカによって実行時に動的にリンクすることでバイナリを実行する方法。
静的リンク - 外部のライブラリファイルをコンパイル時にリンクし、生成する実行ファイルに含める方法。
CTFでよく見るバイナリは、動的リンクで作成されている。
この時動的リンクのバイナリと、静的リンクでstrippedなバイナリでは大きな違いが生まれる。
strippedなバイナリ - シンボル情報が削除されたバイナリのこと。静的リンクでこのバイナリの場合、解析が難しくなる。


